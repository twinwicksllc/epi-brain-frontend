'use client';

import { useState, useEffect, useRef } from 'react';
import { useRouter } from 'next/navigation';
import ProtectedRoute from '@/components/ProtectedRoute';
import ConversationSidebar from '@/components/ConversationSidebar';
import ModeSelector from '@/components/ModeSelector';
import MessageBubble from '@/components/MessageBubble';
import ChatInput from '@/components/ChatInput';
import DepthIndicator from '@/components/DepthIndicator';
import { chatApi, authApi } from '@/lib/api/client';
import { streamChatResponse, simulateStreaming } from '@/lib/streaming';
import { getDepthGradient } from '@/lib/utils/depthColors';
import { LogOut, Menu, X } from 'lucide-react';

interface Message {
  id: string;
  role: 'user' | 'assistant';
  content: string;
  timestamp: string;
}

export default function Dashboard() {
  const router = useRouter();
  const [messages, setMessages] = useState<Message[]>([]);
  const [currentMode, setCurrentMode] = useState('personal_friend');
  const [conversationId, setConversationId] = useState<string | undefined>();
  const [isLoading, setIsLoading] = useState(false);
  const [streamingMessage, setStreamingMessage] = useState('');
  const [isStreaming, setIsStreaming] = useState(false);
  const [sidebarOpen, setSidebarOpen] = useState(true);
  const [currentDepth, setCurrentDepth] = useState<number | null>(null);
  const [depthEnabled, setDepthEnabled] = useState(false);
  const messagesEndRef = useRef<HTMLDivElement>(null);

  const scrollToBottom = () => {
    messagesEndRef.current?.scrollIntoView({ behavior: 'smooth' });
  };

  useEffect(() => {
    scrollToBottom();
  }, [messages, streamingMessage]);

  const handleSendMessage = async (message: string) => {
    if (isLoading || isStreaming) return;

    // Add user message
    const userMessage: Message = {
      id: Date.now().toString(),
      role: 'user',
      content: message,
      timestamp: new Date().toISOString(),
    };
    setMessages(prev => [...prev, userMessage]);
    setIsLoading(true);
    setIsStreaming(true);
    setStreamingMessage('');

    try {
      // Try streaming first
      let fullResponse = '';
      let hasError = false;

      try {
        for await (const chunk of streamChatResponse(message, conversationId, currentMode)) {
          if (chunk.type === 'token' && chunk.content) {
            fullResponse += chunk.content;
            setStreamingMessage(fullResponse);
          } else if (chunk.type === 'error') {
            hasError = true;
            console.error('Streaming error:', chunk.error);
            break;
          } else if (chunk.type === 'done') {
            break;
          }
        }
      } catch (streamError) {
        console.warn('Streaming failed, falling back to regular API:', streamError);
        hasError = true;
      }

      // Fallback to regular API if streaming failed
      if (hasError || !fullResponse) {
        const response = await chatApi.sendMessage(message, conversationId, currentMode);
        fullResponse = response.content;
        
        // Update conversation ID if new
        if (!conversationId && response.conversation_id) {
          setConversationId(response.conversation_id);
        }

        // Update depth if provided
        if (response.depth !== undefined && response.depth !== null) {
          setCurrentDepth(response.depth);
          setDepthEnabled(true);
        }

        // Simulate streaming for the response
        setStreamingMessage('');
        for await (const chunk of simulateStreaming(fullResponse)) {
          if (chunk.type === 'token' && chunk.content) {
            setStreamingMessage(prev => prev + chunk.content);
          }
        }
      }

      // Add assistant message
      const assistantMessage: Message = {
        id: (Date.now() + 1).toString(),
        role: 'assistant',
        content: fullResponse,
        timestamp: new Date().toISOString(),
      };
      setMessages(prev => [...prev, assistantMessage]);
      setStreamingMessage('');
    } catch (error) {
      console.error('Failed to send message:', error);
      const errorMessage: Message = {
        id: (Date.now() + 1).toString(),
        role: 'assistant',
        content: 'Sorry, I encountered an error. Please try again.',
        timestamp: new Date().toISOString(),
      };
      setMessages(prev => [...prev, errorMessage]);
      setStreamingMessage('');
    } finally {
      setIsLoading(false);
      setIsStreaming(false);
    }
  };

  const handleSelectConversation = async (id: string) => {
    try {
      const conversation = await chatApi.getConversation(id);
      setConversationId(id);
      setCurrentMode(conversation.mode || 'personal_friend');
      
      // Load messages
      const loadedMessages: Message[] = conversation.messages.map((msg: any) => ({
        id: msg.id,
        role: msg.role,
        content: msg.content,
        timestamp: msg.timestamp,
      }));
      setMessages(loadedMessages);

      // Fetch current depth
      try {
        const depthInfo = await chatApi.getConversationDepth(id);
        setCurrentDepth(depthInfo.depth);
        setDepthEnabled(depthInfo.enabled);
      } catch (depthError) {
        console.warn('Could not fetch depth info:', depthError);
        setCurrentDepth(null);
        setDepthEnabled(false);
      }
    } catch (error) {
      console.error('Failed to load conversation:', error);
    }
  };

  const handleNewConversation = () => {
    setConversationId(undefined);
    setMessages([]);
    setCurrentMode('personal_friend');
    setCurrentDepth(null);
    setDepthEnabled(false);
  };

  const handleModeChange = (modeId: string) => {
    setCurrentMode(modeId);
  };

  const handleLogout = async () => {
    try {
      await authApi.logout();
    } catch (error) {
      console.error('Logout error:', error);
    } finally {
      router.push('/login');
    }
  };

  return (
    <ProtectedRoute>
      <div 
        className="flex h-screen transition-all duration-1000 ease-in-out"
        style={{ background: getDepthGradient(currentDepth) }}
      >
        {/* Sidebar */}
        <div className={`${sidebarOpen ? 'block' : 'hidden'} md:block`}>
          <ConversationSidebar
            currentConversationId={conversationId}
            onSelectConversation={handleSelectConversation}
            onNewConversation={handleNewConversation}
          />
        </div>

        {/* Main Chat Area */}
        <div className="flex-1 flex flex-col">
          {/* Header */}
          <div className="bg-[#1a0a2e]/80 backdrop-blur-sm border-b border-[#7B3FF2]/20 px-6 py-4 flex items-center justify-between">
            <div className="flex items-center gap-4">
              <button
                onClick={() => setSidebarOpen(!sidebarOpen)}
                className="md:hidden p-2 hover:bg-[#2d1b4e] rounded-lg transition-colors"
              >
                {sidebarOpen ? <X size={24} className="text-white" /> : <Menu size={24} className="text-white" />}
              </button>
              
              <ModeSelector currentMode={currentMode} onModeChange={handleModeChange} />
            </div>

            <div className="flex items-center gap-4">
              <DepthIndicator depth={currentDepth} enabled={depthEnabled} />
              
              <button
                onClick={handleLogout}
                className="flex items-center gap-2 px-4 py-2 hover:bg-[#2d1b4e] rounded-lg transition-colors text-white"
              >
                <LogOut size={20} />
                <span className="hidden sm:inline">Logout</span>
              </button>
            </div>
          </div>

          {/* Messages Area */}
          <div className="flex-1 overflow-y-auto px-6 py-8">
            <div className="max-w-4xl mx-auto">
              {messages.length === 0 && !streamingMessage && (
                <div className="text-center text-gray-400 mt-20">
                  <div className="text-6xl mb-4">ðŸ’¬</div>
                  <h2 className="text-2xl font-bold mb-2 text-white">Start a conversation</h2>
                  <p>Choose a personality mode and send a message to begin</p>
                </div>
              )}

              {messages.map((message) => (
                <MessageBubble
                  key={message.id}
                  role={message.role}
                  content={message.content}
                />
              ))}

              {streamingMessage && (
                <MessageBubble
                  role="assistant"
                  content={streamingMessage}
                  isStreaming={true}
                />
              )}

              <div ref={messagesEndRef} />
            </div>
          </div>

          {/* Input Area */}
          <div className="bg-[#1a0a2e] border-t border-[#7B3FF2]/20 px-6 py-4">
            <div className="max-w-4xl mx-auto">
              <ChatInput
                onSendMessage={handleSendMessage}
                disabled={isLoading || isStreaming}
                placeholder={`Message ${currentMode.replace('_', ' ')}...`}
              />
            </div>
          </div>
        </div>
      </div>
    </ProtectedRoute>
  );
}